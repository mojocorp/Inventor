#ifndef  _SO_TEXTURE_COORDINATE3_ELEMENT
#define  _SO_TEXTURE_COORDINATE3_ELEMENT

#include <Inventor/SbVec3f.h>
#include <Inventor/SbVec4f.h>
#include <Inventor/elements/SoReplacedElement.h>

//////////////////////////////////////////////////////////////////////////////
//
//  Class: SoTextureCoordinate3Element
//
//  Element storing the current texture coordinates
//
//////////////////////////////////////////////////////////////////////////////

// Function that TextureCoordinateFunction nodes register to compute
// texture coordinates.  Given the point and normal, compute a texture
// coordinate and return it:
typedef const SbVec4f &
    SoTextureCoordinateFunctionCB(void *userdata, const SbVec3f &point,
                      const SbVec3f &normal);

SoEXTENDER class INVENTOR_API SoTextureCoordinate3Element : public SoReplacedElement {

    SO_ELEMENT_HEADER(SoTextureCoordinate3Element);

  public:
    /// The (seemingly random) choice of values is for compatibility
    /// with Inventor 2.0 binary format files:
    enum CoordType {
        EXPLICIT = 1,	///< Coordinates stored in state
        FUNCTION = 2	///< Coordinates generated by software function
    };

    /// Initializes element.
    virtual void	init(SoState *state);

    /// Sets the current texture coordinates, in any of several ways:
    /// EXPLICIT, no coordinates (shapes will generate):
    static void		setDefault(SoState *state, SoNode *node);

    /// FUNCTION:
    static void		setFunction(SoState *state, SoNode *node,
                    SoTextureCoordinateFunctionCB *func,
                    void *userData);
    /// EXPLICIT:
    static void		set3(SoState *state, SoNode *node,
                 int32_t numCoords, const SbVec3f *coords);
    static void		set4(SoState *state, SoNode *node,
                 int32_t numCoords, const SbVec4f *coords);

    /// Returns code indicating what has been set in state/element
    static CoordType	getType(SoState *state);
    virtual CoordType	getType() const;

    /// Returns the top (current) instance of the element in the state.
    /// The get routines are called on an instance because it is more
    /// efficient than calling a static method that looks up the
    /// element in the state for every coordinate.
    static const SoTextureCoordinate3Element * getInstance(SoState *state);

    // Get routine for FUNCTION case:

    /// Given point and normal, returns texture coordinate. (The r
    /// coordinate will be 0.0 and the q will be 1.0 until we get 3D
    /// texture coordinate functions.)
    const SbVec4f &	get(const SbVec3f &point, const SbVec3f &normal) const;

    // Get routines for EXPLICIT case:

    /// Returns the number of coordinate points in an instance.
    int32_t		getNum() const		{ return numCoords; }

    SbBool		is3D() const		{ return coordsAre3D; }

    /// Returns the indexed coordinate from an element as a 2-vector, converting if necessary.
    const SbVec3f &	get3(int index) const;

    /// Returns the indexed coordinate from an element as a 4-vector, converting if necessary.
    const SbVec4f &	get4(int index) const;

    /// Prints element (for debugging)
    virtual void	print(FILE *fp) const;

  SoINTERNAL public:
    // Initializes the SoTextureCoordinate3Element class
    static void		initClass();

  protected:
    // What kind of coordinates will be done:
    CoordType		whatKind;

    // Storage for FUNCTION:
    SoTextureCoordinateFunctionCB	*funcCB;
    void				*funcCBData;

    // Storage for EXPLICIT:
    int32_t 		numCoords;
    const SbVec3f	*coords3;
    const SbVec4f	*coords4;
    SbBool		coordsAre3D;

    virtual ~SoTextureCoordinate3Element();

  private:
    SbVec3f		convert3;	// To convert from 4-D to 3-D
    SbVec4f		convert4;	// To convert from 2-D to 4-D
};

#endif /* _SO_TEXTURE_COORDINATE3_ELEMENT */
